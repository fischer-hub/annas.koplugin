# This GitHub Action workflow creates a clean .zip archive of the repository
# when a new release is published. The root directory inside the archive will
# match the repository name, without any version suffix.

name: Create Clean Release ZIP

on:
  release:
    types: [published] # This workflow runs only when you publish a release.

jobs:
  create_zip_and_upload:
    name: Create and Upload Release ZIP
    runs-on: ubuntu-latest
    permissions:
      contents: write # This permission is required to upload assets to a release.

    steps:
      - name: Checkout repository code
        uses: actions/checkout@v4
        
      - name: Bump Version in _meta.lua
        id: bump_version
        run: |
          PLUGIN_DIR="."
          META_FILE="$PLUGIN_DIR/_meta.lua"

          echo "Looking for _meta.lua at $META_FILE"
          if [ ! -f "$META_FILE" ]; then
            echo "Error: $META_FILE not found."
            exit 1
          fi

          CURRENT_VERSION_LINE=$(grep -m 1 '^\s*version\s*=\s*".*"' "$META_FILE")
          if [ -z "$CURRENT_VERSION_LINE" ]; then
            echo "Error: Version line not found in $META_FILE."
            echo "Ensure $META_FILE contains a line like: version = \"1.2.3\""
            exit 1
          fi

          CURRENT_VERSION=$(echo "$CURRENT_VERSION_LINE" | grep -oP '(?<=")[^"]+(?=")')
          if ! [[ "$CURRENT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Version '$CURRENT_VERSION' in $META_FILE is not in X.Y.Z format."
            exit 1
          fi

          MAJOR=$(echo "$CURRENT_VERSION" | cut -d. -f1)
          MINOR=$(echo "$CURRENT_VERSION" | cut -d. -f2)
          PATCH=$(echo "$CURRENT_VERSION" | cut -d. -f3)
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="${{ github.event.release.tag_name }}"

          echo "Current version: $CURRENT_VERSION -> New version: $NEW_VERSION"

          TEMP_META_FILE=$(mktemp)
          sed "s/^\(\s*version\s*=\s*\"\)$CURRENT_VERSION/\1$NEW_VERSION/" "$META_FILE" > "$TEMP_META_FILE" && mv "$TEMP_META_FILE" "$META_FILE"

          if ! grep -q "version\s*=\s*\"$NEW_VERSION\"" "$META_FILE"; then
              echo "Error: Failed to update version in $META_FILE."
              exit 1
          fi
          echo "Successfully updated $META_FILE to version $NEW_VERSION"
          echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
        shell: bash
        

      - name: Create ZIP Archive with Clean Root Directory
        run: |
          # 1. Get the repository name from the GitHub event context.
          repo_name=${{ github.event.repository.name }}
          
          # 2. Create a new directory with the repository's name. This will become the root folder in the archive.
          mkdir $repo_name
          
          # 3. Enable 'dotglob' to ensure hidden files (like .gitignore) are included.
          shopt -s dotglob
          
          # 4. Move all the repository content into the new directory.
          # mv ./* $repo_name/
          mv !($repo_name) $repo_name/
          
          # 5. Create the zip file from the new directory. The '-r' flag makes it recursive.
          zip -9 -r ${repo_name}-{{github.event.release.tag_name}}.zip $repo_name/

      - name: Upload ZIP Archive to Release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          # The URL for uploading assets to the release that triggered this workflow.
          upload_url: ${{ github.event.release.upload_url }} 
          
          # The path to the zip file we just created.
          asset_path: ./${{ github.event.repository.name }}-{{github.event.release.tag_name}}.zip
          
          # The name for the asset file on the release page.
          asset_name: ${{ github.event.repository.name }}-{{github.event.release.tag_name}}.zip
          
          # The content type of the asset.
          asset_content_type: application/zip



